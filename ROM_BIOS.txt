// BIOS cargada en la ROM del XERA4
// Por ahora, sólo inicia la memoria de video 
// y salta a la posición de programa en RAM
06	00	7D	//  0000	LD_VP_15 	h0000  		Ponemos el puntero de video a 0
05	4A	00	//	004A	LD_WP_15	cadena		Puntero WP a los datos de inicialización
0C	30	00	//  0006	LD_BC_16	h030 		48 bytes de datos
2F			//	0009	LDBC_$VP_$WP			Copia bloque de memoria BC numero de bytes
07 00 10	// 	000A	GOTO_15 	4096 		Dirección del primer byte de RAM


			//			SYS_PRNT_STR:					
18			//	000D	LDINC_A_$WP$			Cargamos el caracter en A e incrementamos puntero
13	3A		//	000E	JMPZ_8		retorno		Si A es cero fin de cadena, continuamos con los cambios de tinta
09	20		//	0010	SUB_A_8		h20			Restamos 32, los primeros 32 caracteres no están en la memoria
1A			//	0012	LD_C_A					Copiamos A al byte bajo de BC
1C			//	0013	CLR_B					Borramos el byte alto de BC
1D			//	0014	LLSHIFT_BC
1D			//	0015	LLSHIFT_BC
1D			//	0016	LLSHIFT_BC				Multiplicamos por 8 (bytes por carácter)
1E	00		//	0017	ADD_C_8		bytelowtab	Le sumamos desplazamiento de la tabla de caracteres (ROM)
1F	09		//	0019	ADDC_B_8	bytehitab
24			//	001B	LD_UP_BC				Copiamos BC al puntero UP
2C	08		//	001C	LD_G_8		h8			Cargamos G con el número de líneas
			//			cargaLinea:
17			//	001E	LDINC_A_$UP$			Cargamos en A una línea del caracter (un byte)
25	04		//	001F	LD_E_8		h4			Cargamos en E el número de bytes horizontales
			//			rotacion:
20			//	0021	LLSHIFT_A				Vamos rotando A a la izquierda
26	04		//	0022	JMPC_8		pixelAltoOn	En la bandera Carry tenemos el pixel ON u OFF
27			//	0024	CLR_D					Si está OFF borramos D
08	03		//	0025	RJMP_8		continua
			//			pixelAltoOn:
22	10		//	0027	LD_D_8		blancoalto	Si está ON ponemos color
			//			continua:
20			//	0029	LLSHIFT_A				Volvemos a rotar A para el siguiente pixel
26	03		//	002A	JMPC_8		pixelBajoOn	Si está OFF no sumamos nada
08	03		//	002C	RJMP_8		dibujapix
			//			pixelBajoOn:
28	01		//	002E	ADD_D_8		blancobajo	Si está ON sumamos color en el nibble bajo
			//			dibujapix:
23			//	0030	LDINC_$VP$_D			Copiamos D en la memoria de video
29			//	0031	DEC_E					Disminuímos el contador horizontal
13	03		//	0032	JMPZ_8		siguienteli	Si el contador es 0 nueva linea
08	EC		//	0034	RJMP_8		rotacion
			//			siguienteli:
2A			//	0036	LD_BC_VP				Copiamos el puntero VP a BC para poder operar
1E	9C		//	0037	ADD_C_8		bytebajo156
1F	00		//	0039	ADDC_B_8	bytealto156	Le sumamos el desplazamiento para la siguiente linea
2B			//	003B	LD_VP_BC
2D			//	003C	DEC_G					Disminuímos el contador vertical
13	03		//	003D	JMPZ_8		calculaPos
08	DE		//	003F	RJMP_8		cargaLinea
			//			calculaPos:
2A			//	0041	LD_BC_VP				Copiamos el puntero VP a BC para poder operar
1E	04		//	0042	ADD_C_8		bytelowFB00
1F	FB		//	0044	ADDC_B_8	bytehiFB00	Le restamos el desplazamiento para el siguiente caracter
2B			//	0046	LD_VP_BC
08	C5		//	0047	RJMP_8		cargaCar	Saltamos a leer el siguiente caracter
31			//	0049	RETURN

// Initial video data for XERA4
// 7D00 - 7D1F	inks
00 //Ink 0
00
FF //Ink 1
0F
0F //Ink 2
00
F0 //Ink 3
00
00 //Ink 4
0F
FF //Ink 5
00
F0 //Ink 6
0F
0F //Ink 7
0F
AA //Ink 8
0A
FF //Ink 9
0F
AF //Ink 10
0A
FA //Ink 11
0A
AA //Ink 12
0F
AA //Ink 13
0A
FA //Ink 14
0F
AF //Ink 15
0F
// 7D20 - 7D22 graphic window area X1-Y1 (80,50)
50 00 32
// 7D23 - 7D25 graphic window area X2-Y2  (240,150)
F0 00 96
// 7D26 - 7D28 graphic window visible X1-Y1 (88,58)
58 00 3A
// 7D29 - 7D2B graphic window visible X2-Y2 (232,142)
E8 00 8E
// 7D2C - 7D2E graphic window offset X-Y
00 00 00
// 7D2F void pen
00
